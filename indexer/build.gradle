import org.testcontainers.elasticsearch.ElasticsearchContainer
import org.testcontainers.utility.DockerImageName

buildscript {
  dependencies {
    classpath "org.testcontainers:elasticsearch:${Versions.TEST_CONTAINERS}"
    classpath "org.testcontainers:kafka:${Versions.TEST_CONTAINERS}"
  }
}

plugins {
  id 'application'
}

apply plugin: "com.github.johnrengelman.shadow"

mainClassName = 'org.cedar.onestop.indexer.IndexerApp'

sourceCompatibility = 11
targetCompatibility = 11

configurations {
  integrationTestCompile.extendsFrom testCompile
  integrationTestRuntime.extendsFrom testRuntime
  integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
  integrationTestImplementation.extendsFrom testImplementation
}

dependencies {
  def Versions = project.Versions

  implementation(project(':data-common'))
  implementation(project(':kafka-common'))
  implementation(project(':elastic-common'))
  implementation("com.github.cedardevs.schemas:schemas-core:${Versions.ONESTOP_SCHEMAS}")
  implementation("com.github.cedardevs.schemas:schemas-parse:${Versions.ONESTOP_SCHEMAS}")
  implementation("com.github.cedardevs.schemas:schemas-analyze:${Versions.ONESTOP_SCHEMAS}")
  implementation("org.apache.kafka:kafka-streams:${Versions.KAFKA}")
  implementation("org.apache.kafka:kafka-clients:${Versions.KAFKA}")
  implementation("io.confluent:kafka-streams-avro-serde:${Versions.CONFLUENT}")
  implementation("org.elasticsearch.client:elasticsearch-rest-high-level-client:${Versions.ELASTIC}")
  implementation("org.yaml:snakeyaml:${Versions.SNAKE_YAML}")
  implementation("org.slf4j:slf4j-api:${Versions.SLF4J}")
  implementation("ch.qos.logback:logback-classic:${Versions.LOGBACK}")
  implementation("org.apache.commons:commons-text:1.10.0")

  testImplementation("org.codehaus.groovy:groovy:${Versions.GROOVY}")
  testImplementation(project(path: ':elastic-common', configuration: 'testElastic'))
  testImplementation("org.objenesis:objenesis:3.1")
  testImplementation("net.bytebuddy:byte-buddy:1.7.11")
  testImplementation("org.codehaus.groovy:groovy:${Versions.GROOVY}")
  testImplementation("org.codehaus.groovy:groovy-json:${Versions.GROOVY}")
  testImplementation("org.spockframework:spock-core:${Versions.SPOCK}")
  testImplementation("org.apache.kafka:kafka-streams-test-utils:${Versions.KAFKA}")
  testImplementation("org.springframework.kafka:spring-kafka-test:2.9.5")
  testImplementation("org.apache.kafka:kafka-clients:${Versions.KAFKA}:test")
  testImplementation("org.apache.kafka:kafka_2.12:${Versions.KAFKA}")
  testImplementation("org.apache.kafka:kafka_2.12:${Versions.KAFKA}:test")
  testImplementation("io.confluent:kafka-schema-registry:${Versions.CONFLUENT}")
  testImplementation("io.confluent:kafka-schema-registry:${Versions.CONFLUENT}:tests")
  testImplementation("com.github.cedardevs.schemas:schemas-core:${Versions.ONESTOP_SCHEMAS}:test")
  testImplementation("com.github.cedardevs.schemas:schemas-core:${Versions.ONESTOP_SCHEMAS}:sources")
}

sourceSets {
  integrationTest {
    compileClasspath += sourceSets.main.output + sourceSets.test.output
    runtimeClasspath += sourceSets.main.output + sourceSets.test.output
    groovy.srcDir file('src/integrationTest/groovy')
    resources.srcDir file('src/integrationTest/resources')
  }
}

task integrationTest(type: Test) {
  doFirst {
    // `CI` env var is typically "true" inside CircleCI, Travis, and other CI environments.
    // If you find it is not, the build cmds used within your CI config could also be prefixed like:
    // `export CI=true && ./gradlew integrationTest ...`
    Boolean ci = Boolean.valueOf(System.getenv('CI'))
    if (ci) {
      // the elasticsearch brought up by CircleCI (see `.circleci/config`) runs on localhost:9200
      systemProperty 'elasticsearch.port', '9200'
    }
    else {
      DockerImageName ELASTIC_IMAGE = DockerImageName.parse("docker.elastic.co/elasticsearch/elasticsearch:${ Versions.ELASTIC_SERVER }")
      def elasticsearchContainer = new ElasticsearchContainer(ELASTIC_IMAGE)
      elasticsearchContainer.start() // This can fail if already running. run `docker ps` then `docker stop <container id>`.

      systemProperty 'elasticsearch.port', elasticsearchContainer.getMappedPort(9200)
      project.ext.set("elasticsearchContainer", elasticsearchContainer)
    }

    systemProperty 'elasticsearch.host', 'localhost'
    systemProperty 'elasticsearch.ssl.enabled', false
  }

  description = 'Runs the integration tests'
  group = 'verification'
  testClassesDirs = sourceSets.integrationTest.output.classesDirs
  classpath = sourceSets.integrationTest.runtimeClasspath
  outputs.upToDateWhen { false }
  shouldRunAfter test
  finalizedBy { killElasticsearch }

  reports.junitXml.destination = file("${buildDir}/integration-test-results")
  reports.html.destination = file("${buildDir}/reports/integrationTests")
}
check.dependsOn integrationTest
task killElasticsearch {
  doFirst {
    if (project.extensions.hasProperty("elasticsearchContainer")) {
      project.ext.get("elasticsearchContainer").stop()
    }
  }
}

jar {
  archiveBaseName.set("${rootProject.name}-${project.name}")
  manifest {
    attributes 'Main-Class': mainClassName
  }
}
// check http://imperceptiblethoughts.com/shadow/
shadowJar {
  archiveBaseName.set("${rootProject.name}-${project.name}")
  archiveVersion.set("${project.version}")
  archiveClassifier.set("all")
}

task sourceJar(type: Jar) {
  archiveBaseName.set("${rootProject.name}-${project.name}")
  archiveClassifier.set("sources")
  from "${projectDir}/src"
}

assemble.dependsOn(sourceJar)

task BuildDockerImage {
  group "jib"
  dependsOn jibDockerBuild
}
task PublishDockerImage {
  group "jib"
  dependsOn jib
}

jib {
  use(PublishingKt) {
    def publish = project.publish

    from {
      //base image
      image = 'gcr.io/distroless/java:11'
    }
    to {
      image = publish.repository()
      auth {
        username = publish.username
        password = publish.password
      }
    }
    container {
      creationTime = publish.created.toString()
      labels = publish.ociAnnotations()
    }
  }
}
